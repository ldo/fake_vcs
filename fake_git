#!/usr/bin/python
#+
# This script constructs and fills a git repository in a specified
# directory, synthesizing past history from older versions of the
# files in the directory.
#
# Invoke this script as follows:
#
#     fake_git [options ...] dir
#
# where dir is the directory containing the files, and in which the
# repository is to be created. Older versions of files are recognized by
# having a suffix on their name consisting of an integer version number
# preceded by a space. The version number is supposed to indicate the
# sequence in which the various versions of the file were modified,
# but in fact this script determines the sequence by looking only at
# the modification dates on the files.
#
# On completion, all the older versions of the files WILL BE DELETED,
# leaving only the latest versions.
#
# Valid options (optional unless otherwise indicated) are:
#
#     --autolog
#         If specified, then commit log messages are automatically
#         generated by looking at the revision comments in the initial
#         part of the source files.
#     --binary=name
#         indicates that a file with the specified name is to be treated
#         as binary, not text
#     --delete=oldfile/datetime
#         Specifies that a deletion of oldfile from the repository is to
#         be committed at datetime. All versions of oldfile should have
#         older modification dates than datetime, otherwise an error
#         will be reported. datetime should consist of exactly 14 decimal
#         digits, which are interpreted as YYYYMMDDhhmmss.
#     --localtimezone=zonename
#         If specified, indicates that the modification dates/times of
#         the source files come from a system where they are interpreted
#         as local times in the zone zonename, not UTC, so they have to
#         be converted to UTC. If omitted, the modification dates/times
#         are assumed to already be in UTC.
#     --replace=oldfile/newfile
#         Specifies that a deletion of oldfile from the repository is
#         to be committed at the same time as the addition of the first
#         version of newfile (indicating that oldfile is being replaced by
#         newfile in the project). All versions of oldfile should have
#         older modification dates than any version of newfile, otherwise
#         an error will be reported.
#             This may be specified multiple times to indicate multiple
#         file replacements.
#     --useremail=address
#         The e-mail address to record in the repository commit entries. If
#         omitted, git will take it from your global git configuration.
#     --username=username
#         The username to record in the repository commit entries. If
#         omitted, defaults to the value of the USER environment variable.
#
# Adapted from fake_svn 2008 April 5 by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
# Figured out I wasn't passing TZ to git-commit-tree, add --useremail 2008 April 25.
#-

import sys
import os
import time
import subprocess
import calendar
import re
import getopt

#+
# Useful stuff
#-

def SpawnOut(Cmd, Env = None, Input = None) :
	"""executes Cmd in a subprocess, returning its output as the
	function result. Signals any execution failure."""
	sys.stderr.write("SpawnOut %s {%s}\n" % (repr(Cmd), repr(Env))) # debug
	if Input != None : # debug
		sys.stderr.write(" Input = %s\n" % repr(Input))
	#end if
	Child = subprocess.Popen \
	  (
		args = Cmd,
		stdin = subprocess.PIPE,
		stdout = subprocess.PIPE,
		shell = True,
		env = Env
	  )
	(Stdout, Stderr) = Child.communicate(Input)
	if Child.returncode != 0 :
		raise RuntimeError("SpawnOut: child status %d" % Child.returncode)
	#end if
	return Stdout
#end SpawnOut

def ToUTCTime(TheTime) :
	"""returns TheTime as a set of struct tm items in UTC. TheTime
	is interpreted as local to LocalTimeZone if specified, else UTC."""
	if type(TheTime) == str and len(TheTime) == 14 :
		TheTime = calendar.timegm \
		  (
			(
				int(TheTime[0:4]),
				int(TheTime[4:6]),
				int(TheTime[6:8]),
				int(TheTime[8:10]),
				int(TheTime[10:12]),
				int(TheTime[12:14]),
				None,
				None,
				0,
			)
		  )
	#end if
	if LocalTimeZone != None :
		# it was actually local time, convert to UTC
		ZoneOffset = calendar.timegm(time.localtime(TheTime)) - TheTime
		LocalTime = \
				time.gmtime(TheTime)[:8] \
			+ \
				time.localtime(TheTime - ZoneOffset)[8:]
		  # compute (nearly) correct daylight-saving flag
		  # could still be confused if too close to switchover time,
		  # but what the heck
		TheTime = time.mktime(LocalTime)
	#end if
	return time.gmtime(TheTime)
#end ToUTCTime

def FormatTime(DateTime) :
	"""formats a date/time given as either a string of the form
	YYYYMMDDhhmmss or a structure as might be returned by
	time.gmtime for human display."""
	if type(DateTime) == str and len(DateTime) == 14 :
		Result = \
		  (
			int(DateTime[0:4]),
			int(DateTime[4:6]),
			int(DateTime[6:8]),
			int(DateTime[8:10]),
			int(DateTime[10:12]),
			int(DateTime[12:14])
		  )
	elif type(DateTime) == time.struct_time :
		Result = DateTime[0:6]
	else :
		raise TypeError("can't format DateTime \"%s\"" % DateTime)
	#end if
	return "%04d-%02d-%02dT%02d:%02d:%02dZ" % Result
#end FormatTime

def ShellEscape(Arg) :
	"""returns Arg suitably escaped for use as a command-line argument
	to the Shell."""
	return \
		re.sub \
		  (
			r"[\<\>\"\'\|\&\$\#\;\(\)\[\]\`\~\ \\]",
			lambda Match : "\\" + Match.group(0),
			Arg
		  )
		  # Need to catch anything that might be meaningful to shell
#end ShellEscape

BinaryExtensions = set \
  ((
	".gif",
	".jpg",
	".jpeg",
	".png",
  ))

def IsBinary(FileName) :
	"""does FileName indicate that the file contents are binary rather than text."""
	return (
			FileName in BinaryFileNames
		or
			os.path.splitext(FileName)[1] in BinaryExtensions
	)
#end IsBinary

def GetRevisionComments(Content) :
	"""extracts the revision comments, as written in my usual format,
	from the initial part of the file Content."""
	Comments = "" # initial assumption
	ContentLines = Content.split("\n")
	EndMarker = None # set to non-None if revision comments are found
	if len(ContentLines) >= 3 :
		if ContentLines[0] == "/*" :
			# C/C++ code (note I don't use "//" comments)
			StartMarker = "/*"
			EndMarker = re.compile(r"\*\/")
			LineStrip = re.compile(r"\s*")
		elif ContentLines[1] == "#+" or ContentLines[0] == "#+" :
			# Perl, Python, Tcl, makefile etc
			StartMarker = "#+"
			EndMarker = re.compile(r"\#[\-\+]")
			  # should be just "#-", but I did some typos
			LineStrip = re.compile(r"\#\s*")
		#end if
	#end if
	if EndMarker != None :
		LineNr = 0
		Lines = iter(ContentLines)
		DateMatch = re.compile(r"\d{4} \S+ \d{1,2}") # how I write all my dates
		InHeader = False
		GotRevisions = False
		while True :
			try :
				Line = Lines.next()
			except StopIteration :
				break
			#end try
			if InHeader :
				if LineNr != 0 and EndMarker.match(Line) :
					break
				LineNr += 1
				ToStrip = LineStrip.match(Line)
				if ToStrip != None :
					Line = Line[ToStrip.end():]
				#end if
				if DateMatch.search(Line) :
					GotRevisions = True
				#end if
				if not GotRevisions and len(Line) == 0 :
					Comments = ""
				else :
					Comments += Line + "\n"
				#end if
			else :
				if Line == StartMarker :
					InHeader = True
				#end if
			#end if
		#end while
	#end if
	return Comments
#end GetRevisionComments

def GetChangedComment(OldComment, NewComment) :
	"""returns the trailing part of NewComment that differs from
	OldComment. Assumes that NewComment includes OldComment as a
	prefix."""
	LinesOld = OldComment.split("\n")
	LinesNew = NewComment.split("\n")
	Index = 0
	while True :
		if Index == len(LinesOld) or LinesOld[Index] != LinesNew[Index] :
			Changed = "\n".join(LinesNew[Index:])
			break
		#end if
		Index += 1
	#end while
	return Changed
#end GetChangedComment

#+
# Mainline
#-

(Opts, Args) = getopt.getopt \
  (
	sys.argv[1:],
	"",
	[
		"autolog",
		"binary=",
		"delete=",
		"localtimezone=",
		"replace=",
		"useremail=",
		"username=",
	]
,  )
Autolog = False
BinaryFileNames = set()
Deleting = {}
Replacing = {}
Replaced = {}
UserEmail = None
UserName = os.environ["USER"]
LocalTimeZone = None
for Keyword, Value in Opts :
	if Keyword == "--autolog" :
		Autolog = True
	elif Keyword == "--binary" :
		BinaryFileNames.add(Value)
	elif Keyword == "--delete" :
		(Old, DateTime) = Value.split("/")
		Deleting[Old] = DateTime # converted to UTC below
	elif Keyword == "--localtimezone" :
		LocalTimeZone = Value
	elif Keyword == "--replace" :
		(Old, New) = Value.split("/")
		Replacing[New] = Old
		Replaced[Old] = New
		sys.stderr.write("Replacement \"%s\" => \"%s\"\n" % (Old, New)) # debug
	elif Keyword == "--useremail" :
		UserEmail = Value
	elif Keyword == "--username" :
		UserName = Value
	#end if
#end for
if len(Args) != 1 :
	raise getopt.GetoptError("need exactly one arg, being repository directory")
#end if
RepoDir = Args[0]
if not os.path.isdir(RepoDir) :
	raise getopt.GetoptError("\"%s\" is not a directory" % RepoDir)
#end if
if os.path.isdir(os.path.join(RepoDir, ".git")) :
	raise getopt.GetoptError("\"%s\" is already a git repository" % RepoDir)
#end if
if LocalTimeZone != None :
	os.environ["TZ"] = LocalTimeZone
#end if
for BaseName in Deleting :
	Deleting[BaseName] = ToUTCTime(Deleting[BaseName])
#end for

TrailingDigits = re.compile(r"^(.*)\s+[0-9]+.*$")
  # what I append to old version of a file
Sequence = [] # the sequence of entries into the repository
NrSteps = {} # number of updates for each file
BaseNames = dict()
  # key is names of all files (sans version numbers), value is a
  # dict containing
  # "parent" => parent directory for item, won't exist if item
  #     is not in current revision
  # "binary" => True if the file is binary, False if it is text
  # "nrsteps" => number of revision steps found for this file
Subdirs = set()
  # subdirectories in project (not counting ones only containing
  # old versions of files)

def IncludeItems(ItemsDir, ParentName) :
	"""scans ItemsDir and all its subdirectories for files to include."""
	for Item in os.listdir(ItemsDir) :
		ItemPath = os.path.join(ItemsDir, Item)
		if os.path.isfile(ItemPath) :
			ItemStat = os.stat(ItemPath)
			ItemDate = ToUTCTime(ItemStat.st_mtime)
			ItemMode = ItemStat.st_mode
			ParseName = TrailingDigits.match(Item)
			if ParseName != None :
				# older version of a file
				BaseName = ParseName.group(1)
				OldVersion = True
			else :
				BaseName = Item
				OldVersion = False
			#end if
			if BaseName not in BaseNames :
				BaseNames[BaseName] = {"binary" : IsBinary(BaseName), "nrsteps" : 0}
			#end if
			if not OldVersion :
				if ParentName != "" :
					NameComponents = ParentName.split("/")
					for i in range(1, len(NameComponents)) :
						# note ParentName ends with a "/", and I'm
						# ignoring the empty string following
						Subdirs.add("/".join(NameComponents[:i]))
					#end for
				#end if
				BaseNames[BaseName]["parent"] = ParentName
				  # Note if the file does not exist in the
				  # current revision, I will assume it is
				  # supposed to live in the top-level directory,
				  # since I don't consider parent directories
				  # of old versions significant. Note also I
				  # don't handle items with the same name in
				  # different directories.
			#end if
			BaseNames[BaseName]["nrsteps"] += 1
			Sequence.append \
			  (
				{
					"basename" : BaseName,
					"path" : ItemPath,
					"date" : ItemDate,
					"mode" : ItemMode,
				}
			  )
			if OldVersion :
				Category = "Old"
				ForBase = " for \"%s\"" % BaseName
			else :
				Category = "New"
				ForBase = ""
			#end if
			sys.stderr.write \
			  (
					"%s item \"%s\"%s mod %s\n"
				%
					(
						Category,
						Item,
						ForBase,
						FormatTime(ItemDate)
					)
			  ) # debug
		elif not os.path.islink(ItemPath) and os.path.isdir(ItemPath) :
			IncludeItems(ItemPath, ParentName + Item + "/")
		else :
			sys.stderr.write("Warning: ignoring special file \"%s\"\n" % Item)
		#end if
	#end for
#end IncludeItems

IncludeItems(RepoDir, "")
for BaseName in Replacing :
	if BaseName not in BaseNames :
		raise getopt.GetoptError("No such replacer item as \"%s\"" % BaseName)
	#end if
	if Replacing[BaseName] not in BaseNames :
		raise getopt.GetoptError("No such replacee item as \"%s\"" % Replacing[BaseName])
	#end if
	BaseNames[Replacing[BaseName]]["replaced_by"] = BaseName
#end for
for BaseName in Deleting :
	if BaseName not in BaseNames :
		raise getopt.GetoptError("No such deletion item as \"%s\"" % BaseName)
	#end if
	if BaseNames[BaseName].has_key("parent") :
		raise getopt.GetoptError \
		  (
				"Can't delete item in current revision: \"%s\""
			%
				BaseName
		  )
	#end if
	if BaseNames[BaseName].has_key("replaced_by") :
		raise getopt.GetoptError \
		  (
				"Item can't be both deleted and replaced: \"%s\""
			%
				BaseName
		  )
	#end if
#end for
for BaseName in BaseNames :
	if (
			not BaseNames[BaseName].has_key("parent")
		and
			not BaseNames[BaseName].has_key("replaced_by")
		and
			BaseName not in Deleting
	) :
		raise getopt.GetoptError \
		  (
				"item \"%s\" is not current but has no replacement or deletion"
			%
				BaseName
		  )
	#end if
#end for
for BaseName in Deleting :
	Sequence.append \
	  (
		{
			"basename" : BaseName,
			"action" : "delete",
			"date" : Deleting[BaseName],
		}
	  )
	BaseNames[BaseName]["nrsteps"] += 1
#end for
for Step in Sequence :
	if os.path.basename(Step["path"]) == Step["basename"] :
		# rename latest version away from base name, to avoid
		# conflicts later
		Seq = 1000
		while True :
			NewItemPath = "%s %d" % (Step["path"], Seq)
			if not os.path.exists(NewItemPath) :
				os.rename(Step["path"], NewItemPath)
				Step["path"] = NewItemPath
				break
			#end if
			Seq += 1
		#end while
	#end if
#end for
Sequence.sort \
  (
	cmp = None,
	key = lambda Item : calendar.timegm(Item["date"])
  )
  # so entries are inserted in date order
os.chdir(RepoDir)
SpawnOut("git init")
Added = set()
ReplaceNewlines = re.compile("\\\015\\\012?|\\\012")
if Autolog :
	LastComments = {}
#end if
LastCommit = None # to begin with
for Step in Sequence :
	BaseName = Step["basename"]
	Items = []
	CommitDate = str(calendar.timegm(Step["date"]))
	RevisionEnv = \
	  {
		"GIT_AUTHOR_NAME" : UserName,
		"GIT_AUTHOR_DATE" : CommitDate,
		"GIT_COMMITTER_NAME" : UserName,
		"GIT_COMMITTER_DATE" : CommitDate,
		"TZ" : "UTC",
		  # local timezones should only be relevant in output displays, not in repository
	  }
	if UserEmail != None :
		RevisionEnv["GIT_AUTHOR_EMAIL"] = UserEmail
		RevisionEnv["GIT_COMMITTER_EMAIL"] = UserEmail
	#end if
	ChangeLog = "" # initial assumption
	if Step.get("action", None) == "delete" :
		if BaseNames[BaseName]["nrsteps"] > 1 :
			sys.stderr.write \
			  (
					"Error: premature deletion of \"%s\"\n"
				%
					BaseName
			  )
		#end if
		sys.stderr.write("%s: " % FormatTime(Step["date"]))
		sys.stderr.write("del \"%s\"" % BaseName)
		SpawnOut \
		  (
				"git rm %s"
			%
				(
						BaseNames[BaseName].get("parent", "")
					+
						BaseName,
				)
		  )
	else :
		if Replacing.has_key(BaseName) :
			if BaseNames[Replacing[BaseName]]["nrsteps"] != 0 :
				sys.stderr.write \
				  (
						"Error: premature replacement of \"%s\" by \"%s\"\n"
					%
						(Replacing[BaseName], BaseName)
				  )
			#end if
			sys.stderr.write("%s: " % FormatTime(Step["date"]))
			sys.stderr.write("del \"%s\"\n" % Replacing[BaseName])
			SpawnOut \
			  (
					"git rm %s"
				%
					ShellEscape
					  (
							BaseNames[Replacing[BaseName]].get("parent", "")
						+
							Replacing[BaseName]
					  )
			  )
			del Replacing[BaseName]
		#end if
		Content = open(Step["path"], "rb").read()
		os.unlink(Step["path"])
		if not BaseNames[BaseName]["binary"] :
			Content = ReplaceNewlines.sub("\n", Content)
			if Autolog :
				TheseComments = GetRevisionComments(Content)
				if LastComments.has_key(BaseName) :
					ChangeLog = GetChangedComment \
					  (
						LastComments[BaseName],
						TheseComments
					  )
				else :
					ChangeLog = TheseComments
				#end if
				LastComments[BaseName] = TheseComments
			#end if
		#end if
		TheFile = open(BaseName, "wb")
		TheFile.write(Content)
		TheFile.flush()
		TheFile.close()
		os.chmod(BaseName, Step["mode"])
		sys.stderr.write("%s: " % FormatTime(Step["date"]))
		if BaseName in Added :
			sys.stderr.write("mod \"%s\" <= \"%s\"\n" % (BaseName, Step["path"]))
		else :
			sys.stderr.write("add \"%s\" <= \"%s\"\n" % (BaseName, Step["path"]))
			Added.add(BaseName)
		#end if
		SpawnOut("git add %s" % ShellEscape(BaseName))
	#end if
	TreeName = SpawnOut("git write-tree").rstrip("\n")
	ThisCommit = SpawnOut \
	  (
			"git commit-tree %(tree_name)s%(parent)s"
		%
			{
				"tree_name" : TreeName,
				"parent" : ("", " -p %s" % LastCommit)[LastCommit != None],
			},
		RevisionEnv,
		ChangeLog
	  ).rstrip("\n")
	sys.stderr.write("Commit: %s\n" % ThisCommit)
	LastCommit = ThisCommit
	BaseNames[BaseName]["nrsteps"] -= 1
#end for
SpawnOut("git reset --hard %s" % LastCommit)
