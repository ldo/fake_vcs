#!/usr/bin/python
#+
# This script constructs a simpleminded Subversion repository structure,
# in svnadmin dump format, faking the check-in history by looking
# at the modification dates of the different versions of a set of source
# files.
#
# Invoke this script as follows:
#
#     fake_svn [options...] dir
#
# where dir is the directory containing the source files to be
# included in the repository. It can have subdirectories, which will
# be included in the repository if they contain a current version of any
# source file. Older versions of files are recognized by having a
# suffix on their name consisting of an integer version number preceded
# by a space. The version number is supposed to indicate the sequence in
# which the various versions of the file were modified, but in fact this
# script determines the sequence by looking only at the modification
# dates on the files.
#
# Valid options (optional unless otherwise indicated) are:
#
#     --autolog
#         If specified, then commit log messages are automatically
#         generated by looking at the revision comments in the initial
#         part of the source files.
#     --binary=name
#         indicates that a file with the specified name is to be treated
#         as binary, not text
#     --create=datetime
#         (Required) The creation date/time (in the time zone specified
#         to --localtimezone if present, else UTC) to give the repository
#         (recorded as the date/time for "revision 0".) datetime should
#         consist of exactly 14 decimal digits, which are interpreted as
#         YYYYMMDDhhmmss.
#     --delete=oldfile/datetime
#         Specifies that a deletion of oldfile from the repository is to
#         be committed at datetime. All versions of oldfile should have
#         older modification dates than datetime, otherwise an error
#         will be reported.
#     --localtimezone=zonename
#         If specified, indicates that the modification dates/times of
#         the source files come from a system where they are interpreted
#         as local times in the zone zonename, not UTC, so they have to
#         be converted to UTC. If omitted, the modification dates/times
#         are assumed to already be in UTC.
#     --replace=oldfile/newfile
#         Specifies that a deletion of oldfile from the repository is
#         to be committed at the same time as the addition of the first
#         version of newfile (indicating that oldfile is being replaced by
#         newfile in the project). All versions of oldfile should have
#         older modification dates than any version of newfile, otherwise
#         an error will be reported.
#             This may be specified multiple times to indicate multiple
#         file replacements.
#     --trunk-branches-tags
#         If specified, then the recommended initial repository
#         structure is created, with top-level "trunk", "branches"
#         and "tags" directories, and all files are saved in the
#         repository in the "trunk" directory.
#     --user=username
#         The username to record in the repository commit entries. If
#         omitted, defaults to the value of the USER environment variable.
#     --uuid=idstring
#         The UUID to record to uniquely identify the repository. If
#         omitted, a UUID is randomly generated.
#
# First successful run 2006 March 31 by Lawrence D'Oliveiro
#    <ldo@geek-central.gen.nz>
# Add documentation comments and --localtimezone option 2006 April 1.
# Add --autolog option and rework local time conversion 2006 April 2.
# Add --trunk-branches-tags option 2006 April 3.
# Set svn:executable property on scripts, deal properly with obsoleted
#    replaced items 2006 October 4.
# No more special treatment of "old" subdirectory, add --delete option
#    2007 March 12.
# Allow for additional possibilities in TrailingDigits 2007 August 16.
# Add support for binary files 2007 October 2.
#-

import sys
import os
import time
import calendar
import re
import md5
import getopt

#+
# Useful stuff
#-

class SvnDumpWriter :
	"""encapsulates everything I know about the svnadmin dump format."""

	@staticmethod
	def FormatTime(DateTime) :
		"""formats a date/time given as either a string of the form
		YYYYMMDDhhmmss or a structure as might be returned by
		time.gmtime for inclusion as a property value in a dump."""
		if type(DateTime) == str and len(DateTime) == 14 :
			Result = \
			  (
				int(DateTime[0:4]),
				int(DateTime[4:6]),
				int(DateTime[6:8]),
				int(DateTime[8:10]),
				int(DateTime[10:12]),
				int(DateTime[12:14])
			  )
		elif type(DateTime) == time.struct_time :
			Result = DateTime[0:6]
		else :
			raise TypeError("can't format DateTime \"%s\"" % DateTime)
		#end if
		return "%04d-%02d-%02dT%02d:%02d:%02d.000000Z" % Result
	#end FormatTime

	@staticmethod
	def FormatProps(PropsDict) :
		"""returns a string containing properly-formatted representations
		of the key-value pairs in PropsDict."""
		Result = ""
		for Key in PropsDict.iterkeys() :
			Value = PropsDict[Key]
			Result += \
					"K %d\n%s\nV %d\n%s\n" \
				% \
					(len(Key), Key, len(Value), Value)
		#end for
		return Result + "PROPS-END\n"
	#end FormatProps

	def NewRevision(self, Date, PropsDict) :
		"""writes the header for a new revision."""
		self.Dump.write("Revision-number: %d\n" % self.NextRevision)
		PropsCopy = {"svn:date" : self.FormatTime(Date)}
		if PropsDict != None :
			PropsCopy.update(PropsDict)
		#end if
		PropsStr = self.FormatProps(PropsCopy)
		self.Dump.write("Prop-content-length: %d\n" % len(PropsStr))
		self.Dump.write("Content-length: %d\n" % len(PropsStr))
		self.Dump.write("\n" + PropsStr + "\n")
		self.NextRevision += 1
	#end NewRevision

	def WriteNode(self, Path, Kind, Action, Props, Content) :
		"""writes a node for an item named Path of kind Kind ("file"
		or "dir"), where Action can be "add", "modify" or "delete", and
		Content is the actual contents for the file (or None for a
		directory or a delete action)."""
		self.Dump.write("Node-path: " + Path + "\n")
		if Action != "delete" :
			self.Dump.write("Node-kind: %s\n" % Kind)
		#end if
		self.Dump.write("Node-action: " + Action + "\n")
		if Action == "add" or Props != None :
			if Props == None :
				Props = {}
			#end if
			PropsStr = self.FormatProps(Props)
		else :
			PropsStr = ""
		#end if
		if PropsStr != "" :
			self.Dump.write("Prop-content-length: %d\n" % len(PropsStr))
		#end if
		if Content != None :
			self.Dump.write("Text-content-length: %d\n" % len(Content))
			self.Dump.write \
			  (
					"Text-content-md5: %s\n"
				%
					md5.new(Content).hexdigest()
			  )
			self.Dump.write \
			  (
					"Content-length: %d\n"
				%
					(len(Content) + len(PropsStr))
			  )
		elif len(PropsStr) != 0 :
			self.Dump.write \
			  (
					"Content-length: %d\n"
				%
					len(PropsStr)
			  )
		#end if
		self.Dump.write("\n") # end of header
		if PropsStr != "" :
			self.Dump.write(PropsStr)
		#end if
		if Content != None :
			self.Dump.write(Content + "\n")
		#end if
		self.Dump.write("\n")
	#end WriteNode

	def WriteRevision(self, Date, RevisionProps, Items) :
		"""writes a whole collection of item nodes as a single revision."""
		self.NewRevision(Date, RevisionProps)
		for ThisItem in Items :
			self.WriteNode \
			  (
				Path = self.TrunkPrefix + ThisItem["path"],
				Kind = ThisItem["kind"],
				Action = ThisItem["action"],
				Props = ThisItem.get("props", None),
				Content = ThisItem.get("content", None)
			  )
		#end for
	#end WriteRevision

	def __init__(self, Dump, UUID, CreateDate, TrunkBranchesTags) :
		"""Dump is the stream to which to write the contents of the
		repository dump."""
		self.Dump = Dump
		self.Dump.write("SVN-fs-dump-format-version: 2\n\n")
		self.Dump.write("UUID: " + UUID + "\n\n")
		self.NextRevision = 0
		self.NewRevision(CreateDate, {})
		self.TrunkPrefix = ""
		if TrunkBranchesTags :
			self.NewRevision(CreateDate, {})
			for ThisDir in ("trunk", "branches", "tags") :
				self.WriteNode(ThisDir, "dir", "add", None, None)
			#end for
			self.TrunkPrefix = "trunk/"
		#end if
	#end __init__

#end SvnDumpWriter

def ToUTCTime(TheTime) :
	"""returns TheTime as a set of struct tm items in UTC. TheTime
	is interpreted as local to LocalTimeZone if specified, else UTC."""
	if type(TheTime) == str and len(TheTime) == 14 :
		TheTime = calendar.timegm \
		  (
			(
				int(TheTime[0:4]),
				int(TheTime[4:6]),
				int(TheTime[6:8]),
				int(TheTime[8:10]),
				int(TheTime[10:12]),
				int(TheTime[12:14]),
				None,
				None,
				0,
			)
		  )
	#end if
	if LocalTimeZone != None :
		# it was actually local time, convert to UTC
		ZoneOffset = calendar.timegm(time.localtime(TheTime)) - TheTime
		LocalTime = \
				time.gmtime(TheTime)[:8] \
			+ \
				time.localtime(TheTime - ZoneOffset)[8:]
		  # compute (nearly) correct daylight-saving flag
		  # could still be confused if too close to switchover time,
		  # but what the heck
		TheTime = time.mktime(LocalTime)
	#end if
	return time.gmtime(TheTime)
#end ToUTCTime

def ItemModTime(ItemName) :
	"""returns the modified date/time for ItemName, appropriately
	adjusted if it comes from a system where it was recorded as the
	local time in LocalTimeZone."""
	return ToUTCTime(os.stat(ItemName).st_mtime)
#end ItemModTime

BinaryExtensions = set \
  ((
	".gif",
	".jpg",
	".jpeg",
	".png",
  ))

def IsBinary(FileName) :
	"""does FileName indicate that the file contents are binary rather than text."""
	return (
			FileName in BinaryFileNames
		or
			os.path.splitext(FileName)[1] in BinaryExtensions
	)
#end IsBinary

def GetRevisionComments(Content) :
	"""extracts the revision comments, as written in my usual format,
	from the initial part of the file Content."""
	Comments = "" # initial assumption
	ContentLines = Content.split("\n")
	EndMarker = None # set to non-None if revision comments are found
	if len(ContentLines) >= 3 :
		if ContentLines[0] == "/*" :
			# C/C++ code (note I don't use "//" comments)
			StartMarker = "/*"
			EndMarker = re.compile(r"\*\/")
			LineStrip = re.compile(r"\s*")
		elif ContentLines[1] == "#+" or ContentLines[0] == "#+" :
			# Perl, Python, Tcl, makefile etc
			StartMarker = "#+"
			EndMarker = re.compile(r"\#[\-\+]")
			  # should be just "#-", but I did some typos
			LineStrip = re.compile(r"\#\s*")
		#end if
	#end if
	if EndMarker != None :
		LineNr = 0
		Lines = iter(ContentLines)
		DateMatch = re.compile(r"\d{4} \S+ \d{1,2}") # how I write all my dates
		InHeader = False
		GotRevisions = False
		while True :
			try :
				Line = Lines.next()
			except StopIteration :
				break
			#end try
			if InHeader :
				if LineNr != 0 and EndMarker.match(Line) :
					break
				LineNr += 1
				ToStrip = LineStrip.match(Line)
				if ToStrip != None :
					Line = Line[ToStrip.end():]
				#end if
				if DateMatch.search(Line) :
					GotRevisions = True
				#end if
				if not GotRevisions and len(Line) == 0 :
					Comments = ""
				else :
					Comments += Line + "\n"
				#end if
			else :
				if Line == StartMarker :
					InHeader = True
				#end if
			#end if
		#end while
	#end if
	return Comments
#end GetRevisionComments

def GetChangedComment(OldComment, NewComment) :
	"""returns the trailing part of NewComment that differs from
	OldComment. Assumes that NewComment includes OldComment as a
	prefix."""
	LinesOld = OldComment.split("\n")
	LinesNew = NewComment.split("\n")
	Index = 0
	while True :
		if Index == len(LinesOld) or LinesOld[Index] != LinesNew[Index] :
			Changed = "\n".join(LinesNew[Index:])
			break
		#end if
		Index += 1
	#end while
	return Changed
#end GetChangedComment

#+
# Mainline
#-

(Opts, Args) = getopt.getopt \
  (
	sys.argv[1:],
	"",
	[
		"autolog",
		"binary=",
		"create=",
		"delete=",
		"localtimezone=",
		"replace=",
		"trunk-branches-tags",
		"user=",
		"uuid=",
	]
  )
Autolog = False
BinaryFileNames = set()
CreateDate = None
Deleting = {}
Replacing = {}
Replaced = {}
UserName = os.environ["USER"]
UUID = None
LocalTimeZone = None
TrunkBranchesTags = False
for Keyword, Value in Opts :
	if Keyword == "--autolog" :
		Autolog = True
	elif Keyword == "--binary" :
		BinaryFileNames.add(Value)
	elif Keyword == "--create" :
		CreateDate = Value
	elif Keyword == "--delete" :
		(Old, DateTime) = Value.split("/")
		Deleting[Old] = DateTime # converted to UTC below
	elif Keyword == "--localtimezone" :
		LocalTimeZone = Value
	elif Keyword == "--replace" :
		(Old, New) = Value.split("/")
		Replacing[New] = Old
		Replaced[Old] = New
		sys.stderr.write("Replacement \"%s\" => \"%s\"\n" % (Old, New)) # debug
	elif Keyword == "--trunk-branches-tags" :
		TrunkBranchesTags = True
	elif Keyword == "--user" :
		UserName = Value
	elif Keyword == "--uuid" :
		UUID = Value
	#end if
#end for
if len(Args) != 1 :
	raise getopt.GetoptError("need exactly one arg, being working directory")
#end if
if CreateDate == None :
	raise getopt.GetoptError("Missing --create=date")
#end if
ItemsDir = Args[0]
if not os.path.isdir(ItemsDir) :
	raise getopt.GetoptError("\"%s\" is not a directory" % ItemsDir)
#end if
if UUID == None :
	UUID = open("/proc/sys/kernel/random/uuid").readline().rstrip("\n")
#end if
if LocalTimeZone != None :
	os.environ["TZ"] = LocalTimeZone
	CreateDate = \
			"%04d%02d%02d%02d%02d%02d" \
		% \
			ToUTCTime(CreateDate)[0:6]
#end if
for BaseName in Deleting :
	Deleting[BaseName] = ToUTCTime(Deleting[BaseName])
#end for

TrailingDigits = re.compile(r"^(.*)\s+[0-9]+.*$")
  # what I append to old version of a file
Sequence = [] # the sequence of entries into the repository
NrSteps = {} # number of updates for each file
BaseNames = dict()
  # key is names of all files (sans version numbers), value is a
  # dict containing
  # "parent" => parent directory for item, won't exist if item
  #     is not in current revision
  # "binary" => True if the file is binary, False if it is text
  # "nrsteps" => number of revision steps found for this file
Subdirs = set()
  # subdirectories in project (not counting ones only containing
  # old versions of files)

def IncludeItems(ItemsDir, ParentName) :
	"""scans ItemsDir and all its subdirectories for files to include."""
	for Item in os.listdir(ItemsDir) :
		ItemPath = os.path.join(ItemsDir, Item)
		if os.path.isfile(ItemPath) :
			ItemDate = ItemModTime(ItemPath)
			ParseName = TrailingDigits.match(Item)
			if ParseName != None :
				# older version of a file
				BaseName = ParseName.group(1)
				OldVersion = True
			else :
				BaseName = Item
				OldVersion = False
			#end if
			if BaseName not in BaseNames :
				BaseNames[BaseName] = {"binary" : IsBinary(BaseName), "nrsteps" : 0}
			#end if
			if not OldVersion :
				if ParentName != "" :
					NameComponents = ParentName.split("/")
					for i in range(1, len(NameComponents)) :
						# note ParentName ends with a "/", and I'm
						# ignoring the empty string following
						Subdirs.add("/".join(NameComponents[:i]))
					#end for
				#end if
				BaseNames[BaseName]["parent"] = ParentName
				  # Note if the file does not exist in the
				  # current revision, I will assume it is
				  # supposed to live in the top-level directory,
				  # since I don't consider parent directories
				  # of old versions significant. Note also I
				  # don't handle items with the same name in
				  # different directories.
			#end if
			BaseNames[BaseName]["nrsteps"] += 1
			Sequence.append \
			  (
				{
					"basename" : BaseName,
					"path" : ItemPath,
					"date" : ItemDate,
				}
			  )
			if OldVersion :
				Category = "Old"
				ForBase = " for \"%s\"" % BaseName
			else :
				Category = "New"
				ForBase = ""
			#end if
			sys.stderr.write \
			  (
					"%s item \"%s\"%s mod %s\n"
				%
					(
						Category,
						Item,
						ForBase,
						SvnDumpWriter.FormatTime(ItemDate)
					)
			  ) # debug
		elif not os.path.islink(ItemPath) and os.path.isdir(ItemPath) :
			IncludeItems(ItemPath, ParentName + Item + "/")
		else :
			sys.stderr.write("Warning: ignoring special file \"%s\"\n" % Item)
		#end if
	#end for
#end IncludeItems

IncludeItems(ItemsDir, "")
for BaseName in Replacing :
	if BaseName not in BaseNames :
		raise getopt.GetoptError("No such replacer item as \"%s\"" % BaseName)
	#end if
	if Replacing[BaseName] not in BaseNames :
		raise getopt.GetoptError("No such replacee item as \"%s\"" % Replacing[BaseName])
	#end if
	BaseNames[Replacing[BaseName]]["replaced_by"] = BaseName
#end for
for BaseName in Deleting :
	if BaseName not in BaseNames :
		raise getopt.GetoptError("No such deletion item as \"%s\"" % BaseName)
	#end if
	if BaseNames[BaseName].has_key("parent") :
		raise getopt.GetoptError \
		  (
				"Can't delete item in current revision: \"%s\""
			%
				BaseName
		  )
	#end if
	if BaseNames[BaseName].has_key("replaced_by") :
		raise getopt.GetoptError \
		  (
				"Item can't be both deleted and replaced: \"%s\""
			%
				BaseName
		  )
	#end if
#end for
for BaseName in BaseNames :
	if \
			not BaseNames[BaseName].has_key("parent") \
		and \
			not BaseNames[BaseName].has_key("replaced_by") \
		and \
			BaseName not in Deleting \
	:
		raise getopt.GetoptError \
		  (
				"item \"%s\" is not current but has no replacement or deletion"
			%
				BaseName
		  )
	#end if
#end for
for BaseName in Deleting :
	Sequence.append \
	  (
		{
			"basename" : BaseName,
			"action" : "delete",
			"date" : Deleting[BaseName],
		}
	  )
	BaseNames[BaseName]["nrsteps"] += 1
#end for
Sequence.sort \
  (
	cmp = None,
	key = lambda Item : calendar.timegm(Item["date"])
  )
  # so entries are inserted in date order
Dump = SvnDumpWriter \
  (
	Dump = sys.stdout,
	UUID = UUID,
	CreateDate = CreateDate,
	TrunkBranchesTags = TrunkBranchesTags
  )
if len(Subdirs) != 0 :
	CreateSubdirs = []
	for Subdir in Subdirs :
		CreateSubdirs.append \
		  (
			{
				"path" : Subdir,
				"kind" : "dir",
				"action" : "add",
			}
		  )
	#end for
	CreateSubdirs.sort \
	  (
		cmp = None,
		key = lambda Item : Item["path"]
	  )
	  # ensure parent directories are created before children
	Dump.WriteRevision \
	  (
		Date = CreateDate, # might as well create all subdirectories at start
		RevisionProps = {"svn:author" : UserName},
		Items = CreateSubdirs
	  )
#end if
Added = set()
ReplaceNewlines = re.compile("\\\015\\\012?|\\\012")
if Autolog :
	LastComments = {}
#end if
Executable = set()
for Step in Sequence :
	BaseName = Step["basename"]
	Items = []
	RevisionProps = {"svn:author" : UserName}
	if Step.get("action", None) == "delete" :
		if BaseNames[BaseName]["nrsteps"] > 1 :
			sys.stderr.write \
			  (
					"Error: premature deletion of \"%s\"\n"
				%
					BaseName
			  )
		#end if
		ThisItem = \
			{
				"path" :
						BaseNames[BaseName].get("parent", "")
					+
						BaseName,
				"kind" : "file",
				"action" : "delete",
			}
		Items.append(ThisItem)
		sys.stderr.write("%s: " % SvnDumpWriter.FormatTime(Step["date"]))
		sys.stderr.write("del \"%s\"" % BaseName)
	else :
		if Replacing.has_key(BaseName) :
			if BaseNames[Replacing[BaseName]]["nrsteps"] != 0 :
				sys.stderr.write \
				  (
						"Error: premature replacement of \"%s\" by \"%s\"\n"
					%
						(Replacing[BaseName], BaseName)
				  )
			#end if
			sys.stderr.write("%s: " % SvnDumpWriter.FormatTime(Step["date"]))
			sys.stderr.write("del \"%s\"\n" % Replacing[BaseName])
			Items.append \
			  (
				{
					"path" :
							BaseNames[Replacing[BaseName]].get("parent", "")
						+
							Replacing[BaseName],
					"kind" : "file",
					"action" : "delete",
					"content" : None,
				}
			  )
			del Replacing[BaseName]
		#end if
		Content = open(Step["path"], "r").read()
		if not BaseNames[BaseName]["binary"] :
			Content = ReplaceNewlines.sub("\n", Content)
			if Autolog :
				TheseComments = GetRevisionComments(Content)
				if LastComments.has_key(BaseName) :
					ChangeLog = GetChangedComment \
					  (
						LastComments[BaseName],
						TheseComments
					  )
				else :
					ChangeLog = TheseComments
				#end if
				LastComments[BaseName] = TheseComments
				if ChangeLog != "" :
					RevisionProps["svn:log"] = ChangeLog
				#end if
			#end if
		#end if
		sys.stderr.write("%s: " % SvnDumpWriter.FormatTime(Step["date"]))
		if BaseName in Added :
			sys.stderr.write("mod \"%s\" <= \"%s\"" % (BaseName, Step["path"]))
			Action = "change"
		else :
			sys.stderr.write("add \"%s\" <= \"%s\"" % (BaseName, Step["path"]))
			Added.add(BaseName)
			Action = "add"
		#end if
		ItemProps = None
		if not BaseNames[BaseName]["binary"] and Content[:2] == "#!" :
			if BaseName not in Executable :
				ItemProps = {"svn:executable" : "*"}
				# sometimes I also see "svn:execute" set to "1"
				Executable.add(BaseName)
			#end if
		else :
			if BaseName in Executable :
				ItemProps = {} # is this how to remove the svn:executable property?
				Executable.remove(BaseName)
			#end if
		#end if
		ThisItem = \
			{
				"kind" : "file",
				"path" : BaseNames[BaseName].get("parent", "") + BaseName,
				"action" : Action,
				"content" : Content,
			}
		if ItemProps != None :
			ThisItem["props"] = ItemProps
		#end if
		Items.append(ThisItem)
	#end if
	Dump.WriteRevision \
	  (
		Date = Step["date"],
		RevisionProps = RevisionProps,
		Items = Items
	  )
	BaseNames[BaseName]["nrsteps"] -= 1
	sys.stderr.write("\n")
#end for
