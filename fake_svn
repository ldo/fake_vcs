#!/usr/bin/python
#+
# This script constructs a simpleminded Subversion repository structure,
# in svnadmin dump format, faking the check-in history by looking
# at the modification dates of the different versions of a set of source
# files.
#
# Invoke this script as follows:
#
#     fake_svn [options...] dir
#
# where dir is the directory containing the source files to be
# included in the repository. It must contain the newest version of
# each of the source files at the top level, plus a single subdirectory
# called "old" or "Old" which may have older versions of the source files.
# These are matched up with the corresponding newest version based
# on their name, which must consist of the name of the newest version,
# followed by a space, and then a decimal integer version number.
# The version number is supposed to indicate the sequence in which
# the various versions of the file were modified, but in fact this
# script determines the sequence by looking only at the modification
# dates on the files.
#
# Valid options (optional unless otherwise indicated) are:
#
#     --autolog
#         If specified, then commit log messages are automatically
#         generated by looking at the revision comments in the initial
#         part of the source files.
#     --create=datetime
#         (Required) The UTC creation date/time to give the repository
#         (recorded as the date/time for "revision 0".) datetime should
#         consist of exactly 14 decimal digits, which are interpreted as
#         YYYYMMDDhhmmss.
#     --localtimezone=zonename
#         If specified, indicates that the modification dates/times of
#         the source files come from a system where they are interpreted
#         as local times in the zone zonename, not UTC, so they have to
#         be converted to UTC. If omitted, the modification dates/times
#         are assumed to already be in UTC.
#     --replace=oldfile/newfile
#         Specifies that a deletion of oldfile from the repository is
#         to be committed at the same time as the addition of the first
#         version of newfile (indicating that oldfile is being replaced by
#         newfile in the project). All versions of oldfile should have
#         older modification dates than any version of newfile, otherwise
#         an error will be reported.
#             This may be specified multiple times to indicate multiple
#         file replacements.
#     --trunk-branches-tags
#         If specified, then the recommended initial repository
#         structure is created, with top-level "trunk", "branches"
#         and "tags" directories, and all files are saved in the
#         repository in the "trunk" directory.
#     --user=username
#         The username to record in the repository commit entries. If
#         omitted, defaults to the value of the USER environment variable.
#     --uuid=idstring
#         The UUID to record to uniquely identify the repository. If
#         omitted, a UUID is randomly generated.
#
# First successful run 2006 March 31 by Lawrence D'Oliveiro
#    <ldo@geek-central.gen.nz>
# Add documentation comments and --localtimezone option 2006 April 1.
# Add --autolog option and rework local time conversion 2006 April 2.
# Add --trunk-branches-tags option 2006 April 3.
# Set svn:executable property on scripts, deal properly with obsoleted
#    replaced items 2006 October 4.
#-

import sys
import os
import time
import calendar
import re
import md5
import getopt

class SvnDumpWriter :
	"""encapsulates everything I know about the svnadmin dump format."""

	@staticmethod
	def FormatTime(DateTime) :
		"""formats a date/time given as either a string of the form
		YYYYMMDDhhmmss or a structure as might be returned by
		time.gmtime for inclusion as a property value in a dump."""
		if type(DateTime) == str and len(DateTime) == 14 :
			Result = \
			  (
				int(DateTime[0:4]),
				int(DateTime[4:6]),
				int(DateTime[6:8]),
				int(DateTime[8:10]),
				int(DateTime[10:12]),
				int(DateTime[12:14])
			  )
		elif type(DateTime) == time.struct_time :
			Result = DateTime[0:6]
		else :
			raise TypeError("can't format DateTime \"%s\"" % DateTime)
		#end if
		return "%04d-%02d-%02dT%02d:%02d:%02d.000000Z" % Result
	#end FormatTime

	@staticmethod
	def FormatProps(PropsDict) :
		"""returns a string containing properly-formatted representations
		of the key-value pairs in PropsDict."""
		Result = ""
		for Key in PropsDict.iterkeys() :
			Value = PropsDict[Key]
			Result += \
					"K %d\n%s\nV %d\n%s\n" \
				% \
					(len(Key), Key, len(Value), Value)
		#end for
		return Result + "PROPS-END\n"
	#end FormatProps

	def NewRevision(self, Date, PropsDict) :
		"""writes the header for a new revision."""
		self.Dump.write("Revision-number: %d\n" % self.NextRevision)
		PropsCopy = {"svn:date" : self.FormatTime(Date)}
		if PropsDict != None :
			PropsCopy.update(PropsDict)
		#end if
		PropsStr = self.FormatProps(PropsCopy)
		self.Dump.write("Prop-content-length: %d\n" % len(PropsStr))
		self.Dump.write("Content-length: %d\n" % len(PropsStr))
		self.Dump.write("\n" + PropsStr + "\n")
		self.NextRevision += 1
	#end NewRevision

	def WriteNode(self, Path, Kind, Action, Props, Content) :
		"""writes a node for an item named Path of kind Kind ("file"
		or "dir"), where Action can be "add", "modify" or "delete", and
		Content is the actual contents for the file (or None for a
		directory or a delete action)."""
		self.Dump.write("Node-path: " + Path + "\n")
		if Action != "delete" :
			self.Dump.write("Node-kind: %s\n" % Kind)
		#end if
		self.Dump.write("Node-action: " + Action + "\n")
		if Action == "add" or Props != None :
			if Props == None :
				Props = {}
			#end if
			PropsStr = self.FormatProps(Props)
		else :
			PropsStr = ""
		#end if
		if PropsStr != "" :
			self.Dump.write("Prop-content-length: %d\n" % len(PropsStr))
		#end if
		if Content != None :
			self.Dump.write("Text-content-length: %d\n" % len(Content))
			self.Dump.write \
			  (
					"Text-content-md5: %s\n"
				%
					md5.new(Content).hexdigest()
			  )
			self.Dump.write \
			  (
					"Content-length: %d\n"
				%
					(len(Content) + len(PropsStr))
			  )
		elif len(PropsStr) != 0 :
			self.Dump.write \
			  (
					"Content-length: %d\n"
				%
					len(PropsStr)
			  )
		#end if
		self.Dump.write("\n") # end of header
		if PropsStr != "" :
			self.Dump.write(PropsStr)
		#end if
		if Content != None :
			self.Dump.write(Content + "\n")
		#end if
		self.Dump.write("\n")
	#end WriteNode

	def WriteRevision(self, Date, RevisionProps, Files) :
		"""writes a whole collection of file nodes as a single revision."""
		self.NewRevision(Date, RevisionProps)
		for ThisFile in Files :
			self.WriteNode \
			  (
				self.TrunkPrefix + ThisFile["path"],
				"file",
				ThisFile["action"],
				ThisFile.get("props", None),
				ThisFile["content"]
			  )
		#end for
	#end WriteRevision

	def __init__(self, Dump, UUID, CreateDate, TrunkBranchesTags) :
		"""Dump is the stream to which to write the contents of the
		repository dump."""
		self.Dump = Dump
		self.Dump.write("SVN-fs-dump-format-version: 2\n\n")
		self.Dump.write("UUID: " + UUID + "\n\n")
		self.NextRevision = 0
		self.NewRevision(CreateDate, {})
		self.TrunkPrefix = ""
		if TrunkBranchesTags :
			self.NewRevision(CreateDate, {})
			for ThisDir in ("trunk", "branches", "tags") :
				self.WriteNode(ThisDir, "dir", "add", None, None)
			#end for
			self.TrunkPrefix = "trunk/"
		#end if
	#end __init__

#end SvnDumpWriter

def FileModTime(FileName) :
	"""returns the modified date/time for FileName, appropriately
	adjusted if it comes from a system where it was recorded as the
	local time in LocalTimeZone."""
	TheTime = os.stat(ItemPath).st_mtime
	if LocalTimeZone != None :
		# it was actually local time, convert to UTC
		ZoneOffset = calendar.timegm(time.localtime(TheTime)) - TheTime
		LocalTime = \
				time.gmtime(TheTime)[0:8] \
			+ \
				(time.localtime(TheTime - ZoneOffset)[8],)
		  # compute (nearly) correct daylight-saving flag
		  # could still be confused if too close to switchover time,
		  # but what the heck
		TheTime = time.mktime(LocalTime)
	#end if
	return time.gmtime(TheTime)
#end FileModTime

def GetRevisionComments(Content) :
	"""extracts the revision comments, as written in my usual format,
	from the initial part of the file Content."""
	Comments = "" # initial assumption
	ContentLines = Content.split("\n")
	EndMarker = None # set to non-None if revision comments are found
	if len(ContentLines) >= 3 :
		if ContentLines[0] == "/*" :
			# C/C++ code (note I don't use "//" comments)
			StartMarker = "/*"
			EndMarker = re.compile(r"\*\/")
			LineStrip = re.compile(r"\s*")
		elif ContentLines[1] == "#+" or ContentLines[0] == "#+" :
			# Perl, Python, Tcl, makefile etc
			StartMarker = "#+"
			EndMarker = re.compile(r"\#[\-\+]")
			  # should be just "#-", but I did some typos
			LineStrip = re.compile(r"\#\s*")
		#end if
	#end if
	if EndMarker != None :
		LineNr = 0
		Lines = iter(ContentLines)
		DateMatch = re.compile(r"\d{4} \S+ \d{1,2}") # how I write all my dates
		InHeader = False
		GotRevisions = False
		while True :
			try :
				Line = Lines.next()
			except StopIteration :
				break
			#end try
			if InHeader :
				if LineNr != 0 and EndMarker.match(Line) :
					break
				LineNr += 1
				ToStrip = LineStrip.match(Line)
				if ToStrip != None :
					Line = Line[ToStrip.end():]
				#end if
				if DateMatch.search(Line) :
					GotRevisions = True
				#end if
				if not GotRevisions and len(Line) == 0 :
					Comments = ""
				else :
					Comments += Line + "\n"
				#end if
			else :
				if Line == StartMarker :
					InHeader = True
				#end if
			#end if
		#end while
	#end if
	return Comments
#end GetRevisionComments

def GetChangedComment(OldComment, NewComment) :
	"""returns the trailing part of NewComment that differs from
	OldComment. Assumes that NewComment includes OldComment as a
	prefix."""
	LinesOld = OldComment.split("\n")
	LinesNew = NewComment.split("\n")
	Index = 0
	while True :
		if Index == len(LinesOld) or LinesOld[Index] != LinesNew[Index] :
			Changed = "\n".join(LinesNew[Index:])
			break
		#end if
		Index += 1
	#end while
	return Changed
#end GetChangedComment

#+
# Mainline
#-

(Opts, Args) = getopt.getopt \
  (
	sys.argv[1:],
	"",
	[
		"autolog",
		"create=",
		"localtimezone=",
		"replace=",
		"trunk-branches-tags",
		"user=",
		"uuid=",
	]
  )
Autolog = False
UUID = None
CreateDate = None
Replacing = {}
Replaced = {}
UserName = os.environ["USER"]
LocalTimeZone = None
TrunkBranchesTags = False
for Keyword, Value in Opts :
	if Keyword == "--autolog" :
		Autolog = True
	elif Keyword == "--create" :
		CreateDate = Value
	elif Keyword == "--localtimezone" :
		LocalTimeZone = Value
	elif Keyword == "--replace" :
		(Old, New) = Value.split("/")
		Replacing[New] = Old
		Replaced[Old] = New
		sys.stderr.write("Replacement \"%s\" => \"%s\"\n" % (Old, New)) # debug
	elif Keyword == "--trunk-branches-tags" :
		TrunkBranchesTags = True
	elif Keyword == "--user" :
		UserName = Value
	elif Keyword == "--uuid" :
		UUID = Value
	#end if
#end for
if len(Args) != 1 :
	raise getopt.error("need exactly one arg, being working directory")
#end if
if CreateDate == None :
	raise getopt.error("Missing --create=date")
#end if
ItemsDir = Args[0]
if not os.path.isdir(ItemsDir) :
	raise getopt.error("\"%s\" is not a directory" % ItemsDir)
#end if
OldItemsDir = os.path.join(ItemsDir, "Old")
if not os.path.isdir(OldItemsDir) :
	OldItemsDir = os.path.join(ItemsDir, "old")
#end if
if not os.path.isdir(OldItemsDir) :
	raise getopt.error("Directory \"%s\" does not exist" % OldItemsDir)
#end if
if UUID == None :
	UUID = file("/proc/sys/kernel/random/uuid").readline().rstrip("\n")
#end if
if LocalTimeZone != None :
	os.environ["TZ"] = LocalTimeZone
#end if
Sequence = [] # the sequence of entries into the repository
NrSteps = {} # number of updates for each file
FileNames = set() # names of all files
for Item in os.listdir(ItemsDir) :
	ItemPath = os.path.join(ItemsDir, Item)
	if ItemPath != OldItemsDir :
		if os.path.isfile(ItemPath) :
			ItemDate = FileModTime(ItemPath)
			NrSteps[Item] = 1
			FileNames.add(Item)
			Sequence.append \
			  (
				{
					"basename" : Item,
					"path" : ItemPath,
					"date" : ItemDate,
				}
			  )
			sys.stderr.write \
			  (
					"New item \"%s\" mod %s\n"
				%
					(Item, SvnDumpWriter.FormatTime(ItemDate))
			  ) # debug
		elif os.path.isdir(ItemPath) :
			sys.stderr.write("Warning: ignoring subdirectory \"%s\"\n" % Item)
		else :
			sys.stderr.write("Warning: ignoring special file \"%s\"\n" % Item)
		#end if
	#end if
#end for
TrailingDigits = re.compile(r"^(.*)\s+[0-9]+$")
  # what I append to old version of a file
for Item in os.listdir(OldItemsDir) :
	ItemPath = os.path.join(OldItemsDir, Item)
	ParseName = TrailingDigits.match(Item)
	if ParseName != None :
		BaseName = ParseName.group(1)
		IncludeThisItem = True # to begin with
		if BaseName not in FileNames :
			if BaseName in Replaced :
				NrSteps[BaseName] = 0
				FileNames.add(BaseName)
			else :
				# shouldn't happen
				sys.stderr.write \
				  (
						"Warning: can't find current/replaced item \"%s\""
							" for old item \"%s\"\n"
					%
						(BaseName, Item)
				  )
				IncludeThisItem = False
			#end if
		#end if
		if IncludeThisItem :
			ItemDate = FileModTime(ItemPath)
			NrSteps[BaseName] += 1
			Sequence.append \
			  (
				{
					"basename" : BaseName,
					"path" : ItemPath,
					"date" : ItemDate,
				}
			  )
			sys.stderr.write \
			  (
					"Old item \"%s\" for \"%s\" mod %s\n"
				%
					(
						Item,
						BaseName,
						SvnDumpWriter.FormatTime(ItemDate)
					)
			  ) # debug
		#end if
	else :
		# shouldn't happen
		sys.stderr.write("Warning: ignoring old item \"%s\"\n" % Item)
	#end if
#end for
for Replacer in Replacing :
	if Replacer not in FileNames :
		raise getopt.error("No such replacer item as \"%s\"" % Replacer)
	#end if
	if Replacing[Replacer] not in FileNames :
		raise getopt.error("No such replace item as \"%s\"" % Replacing[Replacer])
	#end if
#end for
Sequence.sort \
  (
	None,
	lambda Item : calendar.timegm(Item["date"])
  )
  # insert entries in date order
Dump = SvnDumpWriter(sys.stdout, UUID, CreateDate, TrunkBranchesTags)
Added = set()
ReplaceNewlines = re.compile("\\\015\\\012?|\\\012")
if Autolog :
	LastComments = {}
#end if
Executable = set()
for Step in Sequence :
	BaseName = Step["basename"]
	Files = []
	if Replacing.has_key(BaseName) :
		if NrSteps[Replacing[BaseName]] != 0 :
			sys.stderr.write("Error: premature replacement of \"%s\" by \"%s\"" % (Replacing[BaseName], BaseName))
		#end if
		sys.stderr.write("%s: " % SvnDumpWriter.FormatTime(Step["date"]))
		sys.stderr.write("del \"%s\"\n" % Replacing[BaseName])
		Files.append \
		  (
			{
				"path" : Replacing[BaseName],
				"action" : "delete",
				"content" : None
			}
		  )
		del Replacing[BaseName]
	#end if
	Content = ReplaceNewlines.sub("\n", file(Step["path"], "r").read())
	  # Note I'm assuming all files are text files!
	RevisionProps = {"svn:author" : UserName}
	if Autolog :
		TheseComments = GetRevisionComments(Content)
		if LastComments.has_key(BaseName) :
			ChangeLog = GetChangedComment \
			  (
				LastComments[BaseName],
				TheseComments
			  )
		else :
			ChangeLog = TheseComments
		#end if
		LastComments[BaseName] = TheseComments
		if ChangeLog != "" :
			RevisionProps["svn:log"] = ChangeLog
		#end if
	#end if
	sys.stderr.write("%s: " % SvnDumpWriter.FormatTime(Step["date"]))
	if BaseName in Added :
		sys.stderr.write("mod \"%s\" <= \"%s\"" % (BaseName, Step["path"]))
		Action = "change"
	else :
		sys.stderr.write("add \"%s\" <= \"%s\"" % (BaseName, Step["path"]))
		Added.add(BaseName)
		Action = "add"
	#end if
	FileProps = None
	if Content[:2] == "#!" :
		if BaseName not in Executable :
			FileProps = {"svn:executable" : "*"}
			# sometimes I also see "svn:execute" set to "1"
			Executable.add(BaseName)
		#end if
	else :
		if BaseName in Executable :
			FileProps = {} # is this how to remove the svn:executable property?
			Executable.remove(BaseName)
		#end if
	#end if
	ThisFile = {"path" : BaseName, "action" : Action, "content" : Content}
	if FileProps != None :
		ThisFile["props"] = FileProps
	#end if
	Files.append(ThisFile)
	Dump.WriteRevision(Step["date"], RevisionProps, Files)
	NrSteps[BaseName] -= 1
	sys.stderr.write("\n")
#end for
