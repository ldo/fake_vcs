#!/usr/bin/python
#+
# This script constructs a simpleminded repository structure,
# in either git fast-import or svnadmin dump format, faking the check-in
# history by looking at the modification dates of the different versions
# of a set of source files.
#
# Invoke this script as follows:
#
#     fake_vcs [options...] dir
#
# where dir is the directory containing the source files to be
# included in the repository. It can have subdirectories, which will
# be included in the repository if they contain a current version of any
# source file. Older versions of files are recognized by having a
# suffix on their name consisting of an integer version number preceded
# by a space. The version number is supposed to indicate the sequence in
# which the various versions of the file were modified, but in fact this
# script determines the sequence by looking only at the modification
# dates on the files.
#
# Valid options (optional unless otherwise indicated) are:
#
#     --autolog
#         If specified, then commit log messages are automatically
#         generated by looking at the revision comments in the initial
#         part of the source files.
#     --binary=name
#         indicates that a file with the specified name is to be treated
#         as binary, not text. Text files automatically have their newlines
#         converted to Unix format. Binary files are not scanned for --autolog
#         commit messages.
#     --create=datetime
#         (Required for Subversion, ignored for Git) The repository creation
#         date/time (in the time zone specified to --localtimezone if present,
#         else UTC) to give the repository (recorded as the date/time for
#         "revision 0".) datetime should consist of exactly 14 decimal digits,
#         which are interpreted as YYYYMMDDhhmmss.
#     --delete=oldfile/datetime
#         Specifies that a deletion of oldfile from the repository is to
#         be committed at datetime. All versions of oldfile should have
#         older modification dates than datetime, otherwise an error
#         will be reported.
#     --localtimezone=zonename
#         If specified, indicates that the modification dates/times of
#         the source files come from a system where they are interpreted
#         as local times in the zone zonename, not UTC, so they have to
#         be converted to UTC. If omitted, the modification dates/times
#         are assumed to already be in UTC.
#     --replace=oldfile/newfile
#         Specifies that a deletion of oldfile from the repository is
#         to be committed at the same time as the addition of the first
#         version of newfile (indicating that oldfile is being replaced by
#         newfile in the project). All versions of oldfile should have
#         older modification dates than any version of newfile, otherwise
#         an error will be reported.
#             This may be specified multiple times to indicate multiple
#         file replacements.
#     --trunk-branches-tags
#         (Subersion only) If specified, then the recommended initial
#         repository structure is created, with top-level "trunk", "branches"
#         and "tags" directories, and all files are saved in the
#         repository in the "trunk" directory.
#     --type=(git|svn)
#         (Required) Specifies the dump file format to write: Git or Subversion.
#     --user=username
#         The username to record in the repository commit entries. If
#         omitted, defaults to the value of the USER environment variable.
#     --uuid=idstring
#         (Subversion only) The UUID to record to uniquely identify the
#         repository. If omitted, a UUID is randomly generated.
#
# First successful run 2006 March 31 by Lawrence D'Oliveiro
#    <ldo@geek-central.gen.nz>
# Add documentation comments and --localtimezone option 2006 April 1.
# Add --autolog option and rework local time conversion 2006 April 2.
# Add --trunk-branches-tags option 2006 April 3.
# Set svn:executable property on scripts, deal properly with obsoleted
#    replaced items 2006 October 4.
# No more special treatment of "old" subdirectory, add --delete option
#    2007 March 12.
# Allow for additional possibilities in TrailingDigits 2007 August 16.
# Add support for binary files 2007 October 2.
# Merge in Git support 2008 July 3.
#-

import sys
import os
import time
import calendar
import re
import md5
import getopt

#+
# Useful stuff
#-

def ToDateItems(DateTime) :
	"""converts DateTime given as either a string of the form YYYYMMDDhhmmss or
	a structure as might be returned by time.gmtime into a tuple (y, m, d, hh, mm, ss)."""
	if type(DateTime) == str and len(DateTime) == 14 :
		Result = \
		  (
			int(DateTime[0:4]),
			int(DateTime[4:6]),
			int(DateTime[6:8]),
			int(DateTime[8:10]),
			int(DateTime[10:12]),
			int(DateTime[12:14])
		  )
	elif type(DateTime) == time.struct_time :
		Result = DateTime[0:6]
	elif type(DateTime) == int or type(DateTime) == float :
		Result = time.gmtime(int(DateTime))[0:6]
	else :
		raise TypeError("can't format DateTime %s" % repr(DateTime))
	#end if
	return Result
#end ToDateItems

def FromDateItems(TheTime) :
	"""converts TheTime to integer seconds."""
	return calendar.timegm(ToDateItems(TheTime) + (None, None, 0))
#end FromDateItems

def FormatTime(TheTime) :
	"""returns TheTime formatted as a YYYYMMDDhhmmss timestamp."""
	return "%04d%02d%02d%02d%02d%02d" % ToDateItems(TheTime)
#end FormatTime

LocalTimeZone = None # default to interpreting user-specified times as UTC

def ToUTCTime(TheTime) :
	"""returns TheTime as a set of struct tm items in UTC. TheTime
	is interpreted as local to LocalTimeZone if not None, else UTC."""
	TheTime = FromDateItems(TheTime)
	if LocalTimeZone != None :
		# it was actually local time, convert to UTC
		ZoneOffset = calendar.timegm(time.localtime(TheTime)) - TheTime
		LocalTime = \
		  (
				time.gmtime(TheTime)[:8]
			+
				time.localtime(TheTime - ZoneOffset)[8:]
		  )
		  # compute (nearly) correct daylight-saving flag
		  # could still be confused if too close to switchover time,
		  # but what the heck
		TheTime = time.mktime(LocalTime)
	#end if
	return time.gmtime(TheTime)
#end ToUTCTime

def ItemModTime(ItemName) :
	"""returns the modified date/time for ItemName, appropriately
	adjusted if it comes from a system where it was recorded as the
	local time in LocalTimeZone."""
	return ToUTCTime(os.stat(ItemName).st_mtime)
#end ItemModTime

#+
# Dump format handling
#
# Common across formats:
#
#    RevisionProps -- mapping of properties for a commit. Recognized keys:
#        author -- author/committer name
#        log -- commit message
#    ItemProps -- mapping of properties for a file/directory item. Recognized keys:
#        executable -- (file only) boolean indicating whether file is executable
#-

class SvnDumpWriter :
	"""encapsulates everything I know about the svnadmin dump format."""

	@staticmethod
	def FormatTime(DateTime) :
		"""formats a date/time for inclusion as a property value in a dump."""
		return "%04d-%02d-%02dT%02d:%02d:%02d.000000Z" % ToDateItems(DateTime)
	#end FormatTime

	@staticmethod
	def FormatProps(PropsDict) :
		"""returns a string containing properly-formatted representations
		of the key-value pairs in PropsDict. Note that entries with values
		of None are ignored."""
		Result = ""
		for Key, Value in PropsDict.iteritems() :
			if Value != None :
				Result += \
				  (
						"K %d\n%s\nV %d\n%s\n"
					%
						(len(Key), Key, len(Value), Value)
				  )
			#end if
		#end for
		return Result + "PROPS-END\n"
	#end FormatProps

	def NewRevision(self, Date, PropsDict) :
		"""writes the header for a new revision."""
		self.Dump.write("Revision-number: %d\n" % self.NextRevision)
		PropsCopy = {"svn:date" : self.FormatTime(Date)}
		if PropsDict != None :
			PropsCopy.update(PropsDict)
		#end if
		PropsStr = self.FormatProps(PropsCopy)
		self.Dump.write("Prop-content-length: %d\n" % len(PropsStr))
		self.Dump.write("Content-length: %d\n" % len(PropsStr))
		self.Dump.write("\n" + PropsStr + "\n")
		self.NextRevision += 1
	#end NewRevision

	def WriteNode(self, Path, Kind, Action, Props, Content) :
		"""writes a node for an item named Path of kind Kind ("file"
		or "dir"), where Action can be "add", "modify" or "delete", and
		Content is the actual contents for the file (or None for a
		directory or a delete action)."""
		self.Dump.write("Node-path: " + Path + "\n")
		if Action != "delete" :
			self.Dump.write("Node-kind: %s\n" % Kind)
		#end if
		self.Dump.write("Node-action: " + Action + "\n")
		if Action == "add" or Props != None :
			if Props == None :
				Props = {}
			#end if
			PropsStr = self.FormatProps(Props)
		else :
			PropsStr = ""
		#end if
		if PropsStr != "" :
			self.Dump.write("Prop-content-length: %d\n" % len(PropsStr))
		#end if
		if Content != None :
			self.Dump.write("Text-content-length: %d\n" % len(Content))
			self.Dump.write \
			  (
					"Text-content-md5: %s\n"
				%
					md5.new(Content).hexdigest()
			  )
			self.Dump.write \
			  (
					"Content-length: %d\n"
				%
					(len(Content) + len(PropsStr))
			  )
		elif len(PropsStr) != 0 :
			self.Dump.write \
			  (
					"Content-length: %d\n"
				%
					len(PropsStr)
			  )
		#end if
		self.Dump.write("\n") # end of header
		if PropsStr != "" :
			self.Dump.write(PropsStr)
		#end if
		if Content != None :
			self.Dump.write(Content + "\n")
		#end if
		self.Dump.write("\n")
	#end WriteNode

	def WriteRevision(self, Date, RevisionProps, Items) :
		"""writes a whole collection of item nodes as a single revision."""
		RevProps = {}
		self.NewRevision \
		  (
			Date = Date,
			PropsDict =
				{
					"svn:author" : RevisionProps.get("author"),
					"svn:log" : RevisionProps.get("log"),
				}
		  )
		for ThisItem in Items :
			if ThisItem["action"] == "delete" :
				NodeProps = None # no props allowed
			else :
				NodeProps = {}
				  # always present even if empty -- is this how to
				  # remove the svn:executable property?
				if ThisItem.get("executable", False) :
					NodeProps["svn:executable"] = "*"
					 # sometimes I also see "svn:execute" set to "1"
				#end if
			#end if
			self.WriteNode \
			  (
				Path = self.TrunkPrefix + ThisItem["path"],
				Kind = ThisItem["kind"],
				Action = ThisItem["action"],
				Props = NodeProps,
				Content = ThisItem.get("content", None)
			  )
		#end for
	#end WriteRevision

	def __init__(self, Dump, CreateDate, UUID, TrunkBranchesTags) :
		"""Dump is the stream to which to write the contents of the
		repository dump."""
		self.Dump = Dump
		self.Dump.write("SVN-fs-dump-format-version: 2\n\n")
		self.Dump.write("UUID: " + UUID + "\n\n")
		self.NextRevision = 0
		self.NewRevision(CreateDate, {})
		self.TrunkPrefix = ""
		if TrunkBranchesTags :
			self.NewRevision(CreateDate, {})
			for ThisDir in ("trunk", "branches", "tags") :
				self.WriteNode(ThisDir, "dir", "add", None, None)
			#end for
			self.TrunkPrefix = "trunk/"
		#end if
	#end __init__

#end SvnDumpWriter

class GitDumpWriter :
	"""writes a dump suitable for reading by git-fast-import."""

	@staticmethod
	def FormatTime(DateTime) :
		"""formats DateTime in Git "raw" format. Always sets timezone part to UTC."""
		return "%d +0000" % FromDateItems(ToUTCTime(DateTime))
	#end FormatTime

	def NewMark(self) :
		# returns a new, unique mark ID.
		self.LastMark += 1
		return self.LastMark
	#end if

	def WriteRevision(self, Date, RevisionProps, Items) :
		"""writes a whole collection of item nodes as a single revision."""
		Files = []
		for Item in Items :
			if Item["kind"] == "file" and (Item["action"] == "add" or Item["action"] == "change") :
				ItemMark = self.NewMark()
				self.Dump.write \
				  (
						"blob\n"
						"mark :%(id)d\n"
						"data %(len)d\n"
						"%(content)s\n"
					%
						{"id" : ItemMark, "len" : len(Item["content"]), "content" : Item["content"]}
				  )
				Files.append \
					(
						{
							"path" : Item["path"],
							"id" : ItemMark,
							"executable" : Item.get("executable", False),
						}
					)
			#end if
		#end for
		CommitMark = self.NewMark()
		CommitMsg = RevisionProps.get("log", "")
		self.Dump.write \
		  (
				"commit refs/heads/master\n"
				"mark :%(id)d\n"
				"author %(author)s %(when)s\n"
				"committer %(author)s %(when)s\n"
				"data %(loglen)d\n"
				"%(log)s\n"
			%
				{
					"id" : CommitMark,
					"author" : RevisionProps["author"],
					"when" : self.FormatTime(Date),
					"loglen" : len(CommitMsg),
					"log" : CommitMsg,
				}
		  )
		if self.LastCommit != None :
			self.Dump.write("from :%d\n" % self.LastCommit)
		#end if
		for Item in Files :
			self.Dump.write \
			  (
					"M %(mode)s :%(id)d %(path)s\n"
				%
					{
						"mode" : ("100644", "100755")[Item.get("executable", False)],
						"id" : Item["id"],
						"path" : Item["path"],
					}
			  )
		#end for
		for Item in Items :
			if Item["kind"] == "file" and Item["action"] == "delete" :
				self.Dump.write("D %s\n" % Item["path"])
			#end if
		#end if
		self.Dump.write("\n") # optional
		self.LastCommit = CommitMark
	#end WriteRevision

	def __init__(self, Dump) :
		"""Dump is the stream to which to write the contents of the
		repository dump."""
		self.Dump = Dump
		self.LastMark = 0
		self.LastCommit = None
		self.Dump.write \
		  (
			"# Git repository dump created by fake_vcs.\n"
		  )
	#end __init__

#end GitDumpWriter

#+
# File content interpretation
#-

BinaryExtensions = set \
  ((
	".gif",
	".jpg",
	".jpeg",
	".png",
  ))

def IsBinary(FileName) :
	"""does FileName indicate that the file contents are binary rather than text."""
	return (
			FileName in BinaryFileNames
		or
			os.path.splitext(FileName)[1] in BinaryExtensions
	)
#end IsBinary

def GetRevisionComments(Content) :
	"""extracts the revision comments, as written in my usual format,
	from the initial part of the file Content."""
	Comments = "" # initial assumption
	ContentLines = Content.split("\n")
	EndMarker = None # set to non-None if revision comments are found
	if len(ContentLines) >= 3 :
		if ContentLines[0] == "/*" :
			# C/C++ code (note I don't use "//" comments)
			StartMarker = "/*"
			EndMarker = re.compile(r"\*\/")
			LineStrip = re.compile(r"\s*")
		elif ContentLines[1] == "#+" or ContentLines[0] == "#+" :
			# Perl, Python, Tcl, makefile etc
			StartMarker = "#+"
			EndMarker = re.compile(r"\#[\-\+]")
			  # should be just "#-", but I did some typos
			LineStrip = re.compile(r"\#\s*")
		#end if
	#end if
	if EndMarker != None :
		LineNr = 0
		Lines = iter(ContentLines)
		DateMatch = re.compile(r"\d{4} \S+ \d{1,2}") # how I write all my dates
		InHeader = False
		GotRevisions = False
		while True :
			try :
				Line = Lines.next()
			except StopIteration :
				break
			#end try
			if InHeader :
				if LineNr != 0 and EndMarker.match(Line) :
					break
				LineNr += 1
				ToStrip = LineStrip.match(Line)
				if ToStrip != None :
					Line = Line[ToStrip.end():]
				#end if
				if DateMatch.search(Line) :
					GotRevisions = True
				#end if
				if not GotRevisions and len(Line) == 0 :
					Comments = ""
				else :
					Comments += Line + "\n"
				#end if
			else :
				if Line == StartMarker :
					InHeader = True
				#end if
			#end if
		#end while
	#end if
	return Comments
#end GetRevisionComments

def GetChangedComment(OldComment, NewComment) :
	"""returns the trailing part of NewComment that differs from
	OldComment. Assumes that NewComment includes OldComment as a
	prefix."""
	LinesOld = OldComment.split("\n")
	LinesNew = NewComment.split("\n")
	Index = 0
	while True :
		if Index == len(LinesOld) or LinesOld[Index] != LinesNew[Index] :
			Changed = "\n".join(LinesNew[Index:])
			break
		#end if
		Index += 1
	#end while
	return Changed
#end GetChangedComment

#+
# Mainline
#-

(Opts, Args) = getopt.getopt \
  (
	sys.argv[1:],
	"",
	[
		"autolog",
		"binary=",
		"create=",
		"delete=",
		"localtimezone=",
		"replace=",
		"trunk-branches-tags",
		"type=",
		"user=",
		"uuid=",
	]
  )
Autolog = False
BinaryFileNames = set()
CreateDate = None
Deleting = {}
Replacing = {}
Replaced = {}
RepositoryType = None
UserName = os.environ["USER"]
UUID = None
TrunkBranchesTags = False
for Keyword, Value in Opts :
	if Keyword == "--autolog" :
		Autolog = True
	elif Keyword == "--binary" :
		BinaryFileNames.add(Value)
	elif Keyword == "--create" :
		CreateDate = Value
	elif Keyword == "--delete" :
		(Old, DateTime) = Value.split("/")
		Deleting[Old] = DateTime # converted to UTC below
	elif Keyword == "--localtimezone" :
		LocalTimeZone = Value
	elif Keyword == "--replace" :
		(Old, New) = Value.split("/")
		Replacing[New] = Old
		Replaced[Old] = New
		sys.stderr.write("Replacement \"%s\" => \"%s\"\n" % (Old, New)) # debug
	elif Keyword == "--trunk-branches-tags" :
		TrunkBranchesTags = True
	elif Keyword == "--type" :
		RepositoryType = Value
		if Value != "git" and Value != "svn" :
			raise getopt.GetoptError("--type must be \"git\" or \"svn\"")
		#end if
	elif Keyword == "--user" :
		UserName = Value
	elif Keyword == "--uuid" :
		UUID = Value
	#end if
#end for
if len(Args) != 1 :
	raise getopt.GetoptError("need exactly one arg, being working directory")
#end if
if RepositoryType == None :
	raise getopt.GetoptError("Missing --type=type")
#end if

if RepositoryType == "git" :
	if CreateDate != None or TrunkBranchesTags or UUID != None :
		raise getopt.GetoptError \
		  (
			"Git repositories don't use --create, --trunk-branches-tags or --uuid"
		  )
	#end if
elif RepositoryType == "svn" :
	if CreateDate == None :
		raise getopt.GetoptError("Missing --create=date for SVN")
	#end if
	if UUID == None :
		UUID = open("/proc/sys/kernel/random/uuid").readline().rstrip("\n")
	#end if
#end if

ItemsDir = Args[0]
if not os.path.isdir(ItemsDir) :
	raise getopt.GetoptError("\"%s\" is not a directory" % ItemsDir)
#end if
if LocalTimeZone != None :
	os.environ["TZ"] = LocalTimeZone
	CreateDate = FormatTime(ToUTCTime(CreateDate)[0:6])
#end if
for BaseName in Deleting :
	Deleting[BaseName] = ToUTCTime(Deleting[BaseName])
#end for

TrailingDigits = re.compile(r"^(.*)\s+[0-9]+.*$")
  # what I append to old version of a file
Sequence = [] # the sequence of entries into the repository
NrSteps = {} # number of updates for each file
BaseNames = dict()
  # key is names of all files (sans version numbers), value is a
  # dict containing
  # "parent" => parent directory for item, won't exist if item
  #     is not in current revision
  # "binary" => True if the file is binary, False if it is text
  # "nrsteps" => number of revision steps found for this file
Subdirs = set()
  # subdirectories in project (not counting ones only containing
  # old versions of files)

def IncludeItems(ItemsDir, ParentName) :
	"""scans ItemsDir and all its subdirectories for files to include."""
	for Item in os.listdir(ItemsDir) :
		ItemPath = os.path.join(ItemsDir, Item)
		if os.path.isfile(ItemPath) :
			ItemDate = ItemModTime(ItemPath)
			ParseName = TrailingDigits.match(Item)
			if ParseName != None :
				# older version of a file
				BaseName = ParseName.group(1)
				OldVersion = True
			else :
				BaseName = Item
				OldVersion = False
			#end if
			if BaseName not in BaseNames :
				BaseNames[BaseName] = {"binary" : IsBinary(BaseName), "nrsteps" : 0}
			#end if
			if not OldVersion :
				if ParentName != "" :
					NameComponents = ParentName.split("/")
					for i in range(1, len(NameComponents)) :
						# note ParentName ends with a "/", and I'm
						# ignoring the empty string following
						Subdirs.add("/".join(NameComponents[:i]))
					#end for
				#end if
				BaseNames[BaseName]["parent"] = ParentName
				  # Note if the file does not exist in the
				  # current revision, I will assume it is
				  # supposed to live in the top-level directory,
				  # since I don't consider parent directories
				  # of old versions significant. Note also I
				  # don't handle items with the same name in
				  # different directories.
			#end if
			BaseNames[BaseName]["nrsteps"] += 1
			Sequence.append \
			  (
				{
					"basename" : BaseName,
					"path" : ItemPath,
					"date" : ItemDate,
				}
			  )
			if OldVersion :
				Category = "Old"
				ForBase = " for \"%s\"" % BaseName
			else :
				Category = "New"
				ForBase = ""
			#end if
			sys.stderr.write \
			  (
					"%s item \"%s\"%s mod %s\n"
				%
					(
						Category,
						Item,
						ForBase,
						FormatTime(ItemDate)
					)
			  ) # debug
		elif not os.path.islink(ItemPath) and os.path.isdir(ItemPath) :
			IncludeItems(ItemPath, ParentName + Item + "/")
		else :
			sys.stderr.write("Warning: ignoring special file \"%s\"\n" % Item)
		#end if
	#end for
#end IncludeItems

IncludeItems(ItemsDir, "")
for BaseName in Replacing :
	if BaseName not in BaseNames :
		raise getopt.GetoptError("No such replacer item as \"%s\"" % BaseName)
	#end if
	if Replacing[BaseName] not in BaseNames :
		raise getopt.GetoptError("No such replacee item as \"%s\"" % Replacing[BaseName])
	#end if
	BaseNames[Replacing[BaseName]]["replaced_by"] = BaseName
#end for
for BaseName in Deleting :
	if BaseName not in BaseNames :
		raise getopt.GetoptError("No such deletion item as \"%s\"" % BaseName)
	#end if
	if BaseNames[BaseName].has_key("parent") :
		raise getopt.GetoptError \
		  (
				"Can't delete item in current revision: \"%s\""
			%
				BaseName
		  )
	#end if
	if BaseNames[BaseName].has_key("replaced_by") :
		raise getopt.GetoptError \
		  (
				"Item can't be both deleted and replaced: \"%s\""
			%
				BaseName
		  )
	#end if
#end for
for BaseName in BaseNames :
	if (
			not BaseNames[BaseName].has_key("parent")
		and
			not BaseNames[BaseName].has_key("replaced_by")
		and
			BaseName not in Deleting
	) :
		raise getopt.GetoptError \
		  (
				"item \"%s\" is not current but has no replacement or deletion"
			%
				BaseName
		  )
	#end if
#end for
for BaseName in Deleting :
	Sequence.append \
	  (
		{
			"basename" : BaseName,
			"action" : "delete",
			"date" : Deleting[BaseName],
		}
	  )
	BaseNames[BaseName]["nrsteps"] += 1
#end for
Sequence.sort \
  (
	cmp = None,
	key = lambda Item : calendar.timegm(Item["date"])
  )
  # so entries are inserted in date order
if RepositoryType == "git" :
	Dump = GitDumpWriter(Dump = sys.stdout)
elif RepositoryType == "svn" :
	Dump = SvnDumpWriter \
	  (
		Dump = sys.stdout,
		CreateDate = CreateDate,
		UUID = UUID,
		TrunkBranchesTags = TrunkBranchesTags
	  )
else :
	raise AssertionError("unrecognized repository type %s" % repr(RepositoryType))
#end if
if len(Subdirs) != 0 :
	CreateSubdirs = []
	for Subdir in Subdirs :
		CreateSubdirs.append \
		  (
			{
				"path" : Subdir,
				"kind" : "dir",
				"action" : "add",
			}
		  )
	#end for
	CreateSubdirs.sort \
	  (
		cmp = None,
		key = lambda Item : Item["path"]
	  )
	  # ensure parent directories are created before children
	Dump.WriteRevision \
	  (
		Date = CreateDate, # might as well create all subdirectories at start
		RevisionProps = {"author" : UserName},
		Items = CreateSubdirs
	  )
#end if
Added = set()
ReplaceNewlines = re.compile("\\\015\\\012?|\\\012")
if Autolog :
	LastComments = {}
#end if
for Step in Sequence :
	BaseName = Step["basename"]
	Items = []
	RevisionProps = {"author" : UserName}
	if Step.get("action", None) == "delete" :
		if BaseNames[BaseName]["nrsteps"] > 1 :
			sys.stderr.write \
			  (
					"Error: premature deletion of \"%s\"\n"
				%
					BaseName
			  )
		#end if
		ThisItem = \
			{
				"path" :
						BaseNames[BaseName].get("parent", "")
					+
						BaseName,
				"kind" : "file",
				"action" : "delete",
			}
		Items.append(ThisItem)
		sys.stderr.write("%s: " % FormatTime(Step["date"]))
		sys.stderr.write("del \"%s\"" % BaseName)
	else :
		if Replacing.has_key(BaseName) :
			if BaseNames[Replacing[BaseName]]["nrsteps"] != 0 :
				sys.stderr.write \
				  (
						"Error: premature replacement of \"%s\" by \"%s\"\n"
					%
						(Replacing[BaseName], BaseName)
				  )
			#end if
			sys.stderr.write("%s: " % FormatTime(Step["date"]))
			sys.stderr.write("del \"%s\"\n" % Replacing[BaseName])
			Items.append \
			  (
				{
					"path" :
							BaseNames[Replacing[BaseName]].get("parent", "")
						+
							Replacing[BaseName],
					"kind" : "file",
					"action" : "delete",
					"content" : None,
				}
			  )
			del Replacing[BaseName]
		#end if
		Content = open(Step["path"], "r").read()
		if not BaseNames[BaseName]["binary"] :
			Content = ReplaceNewlines.sub("\n", Content)
			if Autolog :
				TheseComments = GetRevisionComments(Content)
				if LastComments.has_key(BaseName) :
					ChangeLog = GetChangedComment \
					  (
						LastComments[BaseName],
						TheseComments
					  )
				else :
					ChangeLog = TheseComments
				#end if
				LastComments[BaseName] = TheseComments
				if ChangeLog != "" :
					RevisionProps["log"] = ChangeLog
				#end if
			#end if
		#end if
		sys.stderr.write("%s: " % FormatTime(Step["date"]))
		if BaseName in Added :
			sys.stderr.write("mod \"%s\" <= \"%s\"" % (BaseName, Step["path"]))
			Action = "change"
		else :
			sys.stderr.write("add \"%s\" <= \"%s\"" % (BaseName, Step["path"]))
			Added.add(BaseName)
			Action = "add"
		#end if
		ThisItem = \
			{
				"kind" : "file",
				"path" : BaseNames[BaseName].get("parent", "") + BaseName,
				"executable" : not BaseNames[BaseName]["binary"] and Content[:2] == "#!",
				"action" : Action,
				"content" : Content,
			}
		Items.append(ThisItem)
	#end if
	Dump.WriteRevision \
	  (
		Date = Step["date"],
		RevisionProps = RevisionProps,
		Items = Items
	  )
	BaseNames[BaseName]["nrsteps"] -= 1
	sys.stderr.write("\n")
#end for
